openapi: 3.1.0
info:
  title: Coco FAQ API
  version: 1.0.1
  description: |
    Voice + text API for managing Coconut Beach FAQs üèùÔ∏è
    - Voice flow: "Coco new faq‚Ä¶" ‚Üí Confirm/Cancel
    - Auto pushes to both webhook + Supabase
    - Auto-categorizes FAQs based on keywords

servers:
  - url: https://faq-webhook.vercel.app
    description: Voice-friendly webhook

tags:
  - name: Search
    description: Endpoints for finding FAQs
  - name: Management
    description: Endpoints for creating FAQs
  - name: Categories
    description: FAQ category listing

paths:
  /create:
    post:
      tags: [Management]
      operationId: createFaqWebhook
      summary: Create FAQ via webhook
      x-openai-isConsequential: false
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                question:
                  type: string
                answer:
                  type: string
      responses:
        "200":
          description: FAQ created via webhook
  /insertFaq:
    post:
      tags:
        - Management
      operationId: insertFaq
      summary: Insert FAQ into Supabase with full metadata
      x-openai-isConsequential: false
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: ["question", "answer"]
              properties:
                category:
                  type: string
                  description: "FAQ category (auto-detected if not provided)"
                question:
                  type: string
                  description: "The FAQ question"
                keywords:
                  type: array
                  items:
                    type: string
                  description: "Search keywords (auto-generated if not provided)"
                answer:
                  type: string
                  description: "The FAQ answer"
                is_active:
                  type: boolean
                  default: true
                  description: "Whether the FAQ is active/published"
                image_url:
                  type: string
                  description: "Optional image URL"
      responses:
        "200":
          description: FAQ inserted successfully
          content:
            application/json:
              schema:
                type: object
                properties:
                  id:
                    type: integer
                  confirmation_message:
                    type: string
        "400":
          description: Bad request - missing required fields
        "500":
          description: Database error

x-coco-config:
  voice_input_handler: |
    // Use globalThis for persistent session state across requests
    if (!globalThis.cocoFaqSession) {
      globalThis.cocoFaqSession = {};
    }

    function detectCategory(question) {
      const q = question.toLowerCase();
      if (q.includes("check in") || q.includes("check out") || q.includes("arrival") || q.includes("checkout")) return "check-in & check-out";
      if (q.includes("wifi") || q.includes("internet") || q.includes("network")) return "connectivity";
      if (q.includes("menu") || q.includes("food") || q.includes("restaurant") || q.includes("vegan") || q.includes("vegetarian")) return "food & dining";
      if (q.includes("taxi") || q.includes("ferry") || q.includes("airport") || q.includes("transfer") || q.includes("pier")) return "arrival & transport";
      if (q.includes("swim") || q.includes("beach") || q.includes("pool") || q.includes("sea")) return "beach & safety";
      if (q.includes("baby") || q.includes("kids") || q.includes("family") || q.includes("cot")) return "family";
      if (q.includes("event") || q.includes("birthday") || q.includes("party")) return "events & groups";
      if (q.includes("eco") || q.includes("sustain") || q.includes("environment")) return "eco & environment";
      if (q.includes("emergency") || q.includes("urgent") || q.includes("medical")) return "emergencies";
      if (q.includes("massage") || q.includes("gym") || q.includes("amenities") || q.includes("library") || q.includes("parking")) return "amenities & facilities";
      if (q.includes("market") || q.includes("walking street") || q.includes("activity") || q.includes("tour")) return "activities";
      return "general";
    }

    function extractKeywords(question, answer) {
      const text = `${question} ${answer}`.toLowerCase();
      const words = text.match(/\b\w{3,}\b/g) || [];
      const stopWords = ['the', 'and', 'are', 'for', 'you', 'can', 'what', 'how', 'where', 'when', 'why', 'this', 'that', 'with', 'have', 'from', 'they', 'been', 'will', 'would', 'could', 'should'];
      const filtered = words.filter(word => !stopWords.includes(word));
      return [...new Set(filtered)].slice(0, 8);
    }

    async function handleVoiceFAQ(text) {
      try {
        const lowerText = text.trim().toLowerCase();

        // ‚úÖ Confirmation flow - forgiving for speech-to-text variations
        const confirmWords = ['confirmed', 'confirm', 'yes', 'yeah', 'yep', 'okay', 'ok', 'sure', 'absolutely', 'correct'];
        const cancelWords = ['cancel', 'no', 'nope', 'stop', 'abort', 'nevermind', 'never mind'];
        
        // Clean the text for better matching (remove punctuation, extra spaces)
        const cleanText = lowerText.replace(/[.,!?;]/g, '').replace(/\s+/g, ' ').trim();
        
        const isConfirmation = confirmWords.some(word => 
          cleanText.includes(word) || 
          cleanText.includes(`yes ${word}`) || 
          cleanText.includes(`okay ${word}`) ||
          cleanText === word
        );
        
        if (isConfirmation) {
          console.log('FAQ confirmation received via voice:', cleanText);
          if (globalThis.cocoFaqSession.pendingFaq) {
            const { question, answer } = globalThis.cocoFaqSession.pendingFaq;
            try {
              // Detect category
              const category = detectCategory(question);

              // Extract keywords from question/answer
              const keywords = extractKeywords(question, answer);

              // Push to advanced webhook endpoint with full metadata
              const response = await fetch("https://faq-webhook.vercel.app/insertFaq", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ 
                  category, 
                  question, 
                  answer,
                  keywords,
                  is_active: true 
                })
              });

              if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
              }

              const result = await response.json();

              // Webhook already pushes to Supabase - confirmed! ‚úÖ
              console.log('FAQ saved via webhook -> Supabase:', result);

              globalThis.cocoFaqSession.pendingFaq = null;
              return `‚úÖ Perfect! FAQ added in *${category}*: "${question}" ‚Üí "${answer}" (ID: ${result.id})`;
            } catch (err) {
              console.error("Error saving FAQ:", err);
              return "‚ö†Ô∏è Got your confirmation, but something went wrong saving it. Can you repeat?";
            }
          } else {
            return "I heard you, but I'm not sure which FAQ you were confirming. Can you repeat?";
          }
        }

        // ‚ùå Cancel flow - also forgiving for speech-to-text
        const isCancellation = cancelWords.some(word => 
          cleanText.includes(word) || 
          cleanText === word ||
          cleanText.includes(`no ${word}`)
        );
        
        if (isCancellation) {
          console.log('FAQ cancelled via voice:', cleanText);
          globalThis.cocoFaqSession.pendingFaq = null;
          return "Okay, nothing saved üå¥";
        }

        // üéô Trigger new FAQ
        const triggerRegex = /^new faq\b|^add faq\b|^make faq\b|^create faq\b|^faq\b/i;
        if (triggerRegex.test(lowerText)) {
          // Parse Q + A (multiple patterns for flexibility)
          let match = text.match(/question[,:\s]+(.+?)[,\s]+answer[,:\s]+(.+)/i);
          if (!match) {
            match = text.match(/q[,:\s]+(.+?)[,\s]+a[,:\s]+(.+)/i);
          }
          if (!match) {
            match = text.match(/(.+?)\s{3,}(.+)/i); // fallback: lots of spaces
          }
          
          if (match) {
            const question = match[1].trim();
            const answer = match[2].trim();
            globalThis.cocoFaqSession.pendingFaq = { question, answer };
            console.log('Stored pending FAQ:', { question, answer });
            return `Got it! New FAQ: "${question}" ‚Üí "${answer}". ‚úÖ Confirm?`;
          } else {
            return `üé§ I heard your FAQ request. Could you format it as: "new FAQ, question: [your question], answer: [your answer]"?`;
          }
        }

        return null; // no action
      } catch (err) {
        console.error("Voice handler error:", err);
        return "‚ö†Ô∏è Something went wrong processing your FAQ.";
      }
    }
